// Generated by the protocol buffer compiler.  DO NOT EDIT!
// source: LinkErrorCode.proto

#include "LinkErrorCode.pb.h"

#include <algorithm>

#include <google/protobuf/io/coded_stream.h>
#include <google/protobuf/extension_set.h>
#include <google/protobuf/wire_format_lite.h>
#include <google/protobuf/descriptor.h>
#include <google/protobuf/generated_message_reflection.h>
#include <google/protobuf/reflection_ops.h>
#include <google/protobuf/wire_format.h>
// @@protoc_insertion_point(includes)
#include <google/protobuf/port_def.inc>
namespace AcFunDanmu {
}  // namespace AcFunDanmu
static constexpr ::PROTOBUF_NAMESPACE_ID::Metadata* file_level_metadata_LinkErrorCode_2eproto = nullptr;
static const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor* file_level_enum_descriptors_LinkErrorCode_2eproto[1];
static constexpr ::PROTOBUF_NAMESPACE_ID::ServiceDescriptor const** file_level_service_descriptors_LinkErrorCode_2eproto = nullptr;
const ::PROTOBUF_NAMESPACE_ID::uint32 TableStruct_LinkErrorCode_2eproto::offsets[1] = {};
static constexpr ::PROTOBUF_NAMESPACE_ID::internal::MigrationSchema* schemas = nullptr;
static constexpr ::PROTOBUF_NAMESPACE_ID::Message* const* file_default_instances = nullptr;

const char descriptor_table_protodef_LinkErrorCode_2eproto[] PROTOBUF_SECTION_VARIABLE(protodesc_cold) =
  "\n\023LinkErrorCode.proto\022\nAcFunDanmu*\213\007\n\rLi"
  "nkErrorCode\022\010\n\004SUCC\020\000\022\016\n\tBASIC_MIN\020\220N\022\023\n"
  "\016INTERNEL_ERROR\020\221N\022\030\n\023SERVICE_UNAVAILABL"
  "E\020\222N\022\024\n\017SERVICE_TIMEOUT\020\223N\022\022\n\rINVALID_TO"
  "KEN\020\224N\022\036\n\031REG_ENCYRPT_WITHOUT_TOKEN\020\225N\022\026"
  "\n\021PARSE_PB_HDR_FAIL\020\226N\022\026\n\021PARSE_PB_PLD_F"
  "AIL\020\227N\022\022\n\rPARSE_PB_FAIL\020\230N\022\025\n\020DECODED_LE"
  "N_FAIL\020\231N\022\020\n\013INVALID_KEY\020\232N\022\021\n\014ENCRYPT_F"
  "AIL\020\233N\022\021\n\014DECRYPT_FAIL\020\234N\022\020\n\013INVALID_TAG"
  "\020\235N\022\020\n\013INVALID_VER\020\236N\022\032\n\025INVALID_COMPRES"
  "S_TYPE\020\240N\022\031\n\024INVALID_ENCRYPT_TYPE\020\241N\022\021\n\014"
  "NOT_REGISTER\020\242N\022\024\n\017USER_NOT_ONLINE\020\243N\022\024\n"
  "\017INVALID_COMMAND\020\244N\022\032\n\025PUSH_UNREGISTER_E"
  "RROR\020\245N\022\020\n\013INVALID_SID\020\246N\022\030\n\023INVALID_INS"
  "TANCE_ID\020\247N\022\034\n\027CLIENT_LOCALE_NOT_MATCH\020\250"
  "N\022#\n\036INVALID_TOKEN_PASSWORD_CHANGED\020\251N\022 "
  "\n\033INVALID_TOKEN_TOKEN_EXPIRED\020\252N\022$\n\037INVA"
  "LID_TOKEN_TOKEN_VALUE_ERROR\020\253N\022(\n#INVALI"
  "D_TOKEN_LOGIN_ON_OTHER_DEVICE\020\254N\022\024\n\017FORC"
  "E_RECONNECT\020\255N\022\023\n\016CLIENT_TIMEOUT\020\256N\022\025\n\020I"
  "NVALID_ARGUMENT\020\257N\022\031\n\024INVALID_FORMAT_TOK"
  "EN\020\260N\022\022\n\rEMPTY_PAYLOAD\020\261N\022\022\n\rCOMPRESS_FA"
  "IL\020\262N\022\024\n\017DECOMPRESS_FAIL\020\263N\022\021\n\014OUT_OF_OR"
  "DER\020\264N\022\017\n\tBASIC_MAX\020\237\234\001b\006proto3"
  ;
static const ::PROTOBUF_NAMESPACE_ID::internal::DescriptorTable*const descriptor_table_LinkErrorCode_2eproto_deps[1] = {
};
static ::PROTOBUF_NAMESPACE_ID::internal::SCCInfoBase*const descriptor_table_LinkErrorCode_2eproto_sccs[1] = {
};
static ::PROTOBUF_NAMESPACE_ID::internal::once_flag descriptor_table_LinkErrorCode_2eproto_once;
const ::PROTOBUF_NAMESPACE_ID::internal::DescriptorTable descriptor_table_LinkErrorCode_2eproto = {
  false, false, descriptor_table_protodef_LinkErrorCode_2eproto, "LinkErrorCode.proto", 951,
  &descriptor_table_LinkErrorCode_2eproto_once, descriptor_table_LinkErrorCode_2eproto_sccs, descriptor_table_LinkErrorCode_2eproto_deps, 0, 0,
  schemas, file_default_instances, TableStruct_LinkErrorCode_2eproto::offsets,
  file_level_metadata_LinkErrorCode_2eproto, 0, file_level_enum_descriptors_LinkErrorCode_2eproto, file_level_service_descriptors_LinkErrorCode_2eproto,
};

// Force running AddDescriptors() at dynamic initialization time.
static bool dynamic_init_dummy_LinkErrorCode_2eproto = (static_cast<void>(::PROTOBUF_NAMESPACE_ID::internal::AddDescriptors(&descriptor_table_LinkErrorCode_2eproto)), true);
namespace AcFunDanmu {
const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor* LinkErrorCode_descriptor() {
  ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&descriptor_table_LinkErrorCode_2eproto);
  return file_level_enum_descriptors_LinkErrorCode_2eproto[0];
}
bool LinkErrorCode_IsValid(int value) {
  switch (value) {
    case 0:
    case 10000:
    case 10001:
    case 10002:
    case 10003:
    case 10004:
    case 10005:
    case 10006:
    case 10007:
    case 10008:
    case 10009:
    case 10010:
    case 10011:
    case 10012:
    case 10013:
    case 10014:
    case 10016:
    case 10017:
    case 10018:
    case 10019:
    case 10020:
    case 10021:
    case 10022:
    case 10023:
    case 10024:
    case 10025:
    case 10026:
    case 10027:
    case 10028:
    case 10029:
    case 10030:
    case 10031:
    case 10032:
    case 10033:
    case 10034:
    case 10035:
    case 10036:
    case 19999:
      return true;
    default:
      return false;
  }
}


// @@protoc_insertion_point(namespace_scope)
}  // namespace AcFunDanmu
PROTOBUF_NAMESPACE_OPEN
PROTOBUF_NAMESPACE_CLOSE

// @@protoc_insertion_point(global_scope)
#include <google/protobuf/port_undef.inc>
